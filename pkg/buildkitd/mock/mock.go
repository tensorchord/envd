// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/buildkitd/buildkitd.go

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"
	time "time"

	gomock "github.com/golang/mock/gomock"
	client "github.com/moby/buildkit/client"
	llb "github.com/moby/buildkit/client/llb"
	client0 "github.com/moby/buildkit/frontend/gateway/client"
)

// MockClient is a mock of Client interface.
type MockClient struct {
	ctrl     *gomock.Controller
	recorder *MockClientMockRecorder
}

// MockClientMockRecorder is the mock recorder for MockClient.
type MockClientMockRecorder struct {
	mock *MockClient
}

// NewMockClient creates a new mock instance.
func NewMockClient(ctrl *gomock.Controller) *MockClient {
	mock := &MockClient{ctrl: ctrl}
	mock.recorder = &MockClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockClient) EXPECT() *MockClientMockRecorder {
	return m.recorder
}

// Build mocks base method.
func (m *MockClient) Build(ctx context.Context, opt client.SolveOpt, product string, buildFunc client0.BuildFunc, statusChan chan *client.SolveStatus) (*client.SolveResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Build", ctx, opt, product, buildFunc, statusChan)
	ret0, _ := ret[0].(*client.SolveResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Build indicates an expected call of Build.
func (mr *MockClientMockRecorder) Build(ctx, opt, product, buildFunc, statusChan interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Build", reflect.TypeOf((*MockClient)(nil).Build), ctx, opt, product, buildFunc, statusChan)
}

// BuildkitdAddr mocks base method.
func (m *MockClient) BuildkitdAddr() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BuildkitdAddr")
	ret0, _ := ret[0].(string)
	return ret0
}

// BuildkitdAddr indicates an expected call of BuildkitdAddr.
func (mr *MockClientMockRecorder) BuildkitdAddr() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuildkitdAddr", reflect.TypeOf((*MockClient)(nil).BuildkitdAddr))
}

// Close mocks base method.
func (m *MockClient) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockClientMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockClient)(nil).Close))
}

// Prune mocks base method.
func (m *MockClient) Prune(ctx context.Context, keepDuration time.Duration, keepStorage float64, filter []string, verbose, all bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Prune", ctx, keepDuration, keepStorage, filter, verbose, all)
	ret0, _ := ret[0].(error)
	return ret0
}

// Prune indicates an expected call of Prune.
func (mr *MockClientMockRecorder) Prune(ctx, keepDuration, keepStorage, filter, verbose, all interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Prune", reflect.TypeOf((*MockClient)(nil).Prune), ctx, keepDuration, keepStorage, filter, verbose, all)
}

// Solve mocks base method.
func (m *MockClient) Solve(ctx context.Context, def *llb.Definition, opt client.SolveOpt, statusChan chan *client.SolveStatus) (*client.SolveResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Solve", ctx, def, opt, statusChan)
	ret0, _ := ret[0].(*client.SolveResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Solve indicates an expected call of Solve.
func (mr *MockClientMockRecorder) Solve(ctx, def, opt, statusChan interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Solve", reflect.TypeOf((*MockClient)(nil).Solve), ctx, def, opt, statusChan)
}
